import random
from typing import List, Dict


# Class representing transitions in a finite automaton
class Transitions:
    def __init__(self, current_state, next_state, transition_label):
        # Instance variables
        self.current_state, self.next_state, self.transition_label = current_state, next_state, transition_label

    def __str__(self):
        # String representation of next state
        return str(self.next_state)

    # Getter methods for instance variables
    def get_current_state(self): return self.current_state

    def get_next_state(self): return self.next_state

    def get_transition_label(self): return self.transition_label


# def to_finite_automaton(self):
#     states = set(self.non_terminals) | {''}
#     final_states = {''}
#     transitions = [Transitions(non_terminal, right_side[1] if len(right_side) > 1 else '', right_side[0]) for
#                    non_terminal in self.Vn for right_side in self.productions[non_terminal]]
#     automaton = FiniteAutomata(transitions)
#     automaton.put_states(states)
#     automaton.put_first_state(str(self.S))
#     automaton.put_accept_states(final_states)
#     automaton.put_alphabet(self.terminals)
#     return automaton


# Class representing a formal grammar
class Grammar:

    def __init__(self, S: str, Vt: List[str], Vn: List[str], P: Dict[str, List[str]]):
        # Instance variables
        self.S = S
        self.Vt = Vt
        self.Vn = Vn
        self.P = P

    # Method that generates a random word in the language generated by the grammar
    def generate_string(self, character: str = None) -> str:
        if character is None:
            character = self.S
        if character in self.Vt:
            # If character is a terminal symbol, return it
            return character
        right_sides = self.P[character]
        random_right_side = random.choice(right_sides)
        word = ''
        for right_char in random_right_side:
            # Recursively generate a word for each symbol in the production
            word += self.generate_string(right_char)
        return word

    # Method that classifies the grammar based on its type
    def classify_grammar(self):
        # Check each production to determine the type of the grammar
        # Check if any production is of length greater than 2 or has invalid symbols, indicating a Type 2 grammar
        for nonTerminal in self.Vn:
            for production in self.P[nonTerminal]:
                if len(production) > 2 or not (
                        production[0] in self.Vt or production[0] in self.Vn) or (
                        len(production) == 2 and production[1] not in self.Vn):
                    return 'Type 2'

        # Check if any non-start nonterminal has more than one production, or if the production is not of the form
        # A -> a or A -> aB, indicating a Type 3 grammar
        for nonTerminal in self.Vn:
            if nonTerminal != self.S:
                if len(self.P[nonTerminal]) > 1 or not (
                        len(self.P[nonTerminal][0]) == 1 and (
                        self.P[nonTerminal][0][0] in self.Vt or self.P[nonTerminal][0][0] in self.Vn)):
                    return 'Type 3'

        # Check if any symbol outside of start symbol is used in a right-hand side, indicating a Type 0 grammar
        for nonTerminal in self.Vn:
            for production in self.P[nonTerminal]:
                for symbol in production:
                    if symbol not in self.Vt and symbol not in self.S:
                        return 'Type 0'

        # If none of the above conditions are met, the grammar is of Type 1
        return 'Type 1'

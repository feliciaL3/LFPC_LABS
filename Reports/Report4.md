# Laboratory Work Nr.4 Chomsky Normal Form
## Course: Formal Languages & Finite Automata
## Author: Felicia Lupascu
## Variant 15

****
## Theory: 
<p align="justify">&ensp;&ensp;&ensp; The Chomsky normal form imposes two restrictions on the production rules of a CFG:
Each production rule must be of the form A → BC or A → a, where A, B, and C are non-terminal symbols, and a is a terminal symbol.
The starting symbol S cannot appear on the right-hand side of any production rule.
By applying these restrictions, we can simplify the analysis and processing of the grammar. For example, it becomes easier to check if a string belongs to the language generated by the grammar, or to construct a parse tree for the string.
The conversion of a CFG to Chomsky normal form involves several steps, such as eliminating epsilon productions, eliminating unit productions, and introducing new non-terminal symbols. This process can sometimes result in an exponential blow-up of the size of the grammar, but it is still a useful technique in many cases.
Chomsky normal form is also related to other concepts in formal language theory, such as pushdown automata, the pumping lemma, and the CYK parsing algorithm. It has applications in various fields, such as natural language processing, computational biology, and compiler design. <p>

## Objectives:
1. Learn about Chomsky Normal Form (CNF) [1].
2. Get familiar with the approaches of normalizing a grammar.
3. Implement a method for normalizing an input grammar by the rules of CNF.
    1. The implementation needs to be encapsulated in a method with an appropriate signature (also ideally in an appropriate class/type).
    2. The implemented functionality needs executed and tested.
    3. A BONUS point will be given for the student who will have unit tests that validate the functionality of the project.
    4. Also, another BONUS point would be given if the student will make the aforementioned function to accept any grammar, not only the one from the student's variant.

****
## Implementation

<p align="justify">&ensp;&ensp;&ensp; For the implementation of this laboratory I needed 3 classes:  Main, UnitTest and Grammar.
Next, each class and its functionality will be explained. <p>

####  Main Class


    S = 'S'
    Vn = ['S', 'A', 'B', 'C', 'D']
    Vt = ['a', 'b']
    P = {'S': ['AC', 'bA', 'B', 'aA'],
         'A': ['ABab', 'aS', 'epsilon'],
         'B': ['a', 'bS'],
         'C': ['abC'],
         'D': ['AB']}

<p align="justify">&ensp;&ensp;&ensp; This class defines a grammar object and converts the grammar to Chomsky Normal Form using the toChomskyNormalForm() method. The grammar is defined by the variables S, Vn, Vt, and P. 
The Grammar class is imported from the grammar module, and the constants Blue and END are defined for colored terminal output.
The code then creates a grammar object using the Grammar class and prints the original grammar and the grammar in Chomsky Normal Form. <p>

#### Grammar Class
<p align="justify">&ensp;&ensp;&ensp; This is a class that represents a context-free grammar. 
It contains methods to transform the grammar into Chomsky Normal Form,
which is a specific form that allows for efficient parsing. 
The methods are removeEpsilon, removeUnitProductions, removeRemainingUnits , removeInaccessible, and removeNonProductive. </p>

```` python
    def toChomskyNormalForm(self):
        print("--------------------------")
        self.removeEpsilon()
        print("Step 1. Removing Epsilon: \n" + "Vt: ", self.Vt, "\nVn: ", self.Vn, "\nP: ", self.P)
        print("--------------------------")
        self.removeUnitProductions()
        print("Step 2. Removing Unit Productions: \n" + "Vt: ", self.Vt, "\nVn: ", self.Vn, "\nP: ", self.P)
        print("--------------------------")
        self.removeInaccessible()
        print("Step 3. Removing Inaccessible: \n" + "Vt: ", self.Vt, "\nVn: ", self.Vn, "\nP: ", self.P)
        print("--------------------------")
        self.removeNonProductive()
        print("Step 4. Removing Non-Productive: \n" + "Vt: ", self.Vt, "\nVn: ", self.Vn, "\nP: ", self.P)
        print("--------------------------")
````
* RemoveEpsilon()
<p align="justify">&ensp;&ensp;&ensp; This is a method defined in a Python class that removes epsilon productions from a context-free grammar.
Epsilon productions are productions that generate an empty string (i.e., a production of the form A -> epsilon, where A is a nonterminal symbol). 
The method first creates a set to store the non-terminal symbols that generate epsilon productions. It then iterates through each production in the grammar and adds any nonterminal symbols that generate epsilon productions to the set. Next, the method iterates through each production in the grammar again and replaces any occurrence of a nonterminal symbol that generates epsilon with an empty string in the right-hand side of the production. If the resulting string is not already a production for the left-hand side of the production, it is added. 
Finally, any epsilon productions in the grammar are removed. The method returns the updated grammar. </p>

```` python
    def removeEpsilon(self):
        # Create a set to store variables that produce epsilon
        epsilon = set()
        # Iterate through each variable in the grammar
        for variable, P in self.P.items():
            # If the production for a variable contains epsilon, add it to the set
            if "epsilon" in P:
                epsilon.add(variable)
        for left, right in self.P.items():
            for i in right:
                # Iterate through each variable that produces epsilon
                for j in epsilon:
                    # If the variable that produces epsilon is in the right-hand side of the production
                    if j in i:
                        # If the variable that produces epsilon is the same as the left-hand side of the production,
                        # skip to the next variable that produces epsilon
                        if left == j:
                            break
                        # Replace the variable that produces epsilon with an empty string in the right-hand side of the production
                        # and add the resulting string to the list of productions for the left-hand side of the production
                        self.P[left] = [x.replace(j, "") for x in self.P[left]]
                        self.P[left].append(i)
                        # If the right-hand side of the production is epsilon, remove it from the list of productions
                    elif i == "epsilon":
                        self.P[left].remove(i)
        return self.P
 ````

* removeUnitProductions()

<p align="justify">&ensp;&ensp;&ensp; This code is implementing an algorithm to remove unit productions from a context-free grammar.
A unit production is a production rule of the form A → B, where A and B are non-terminal symbols. 
The idea behind removing unit productions is to replace them with all productions that directly produce a terminal symbol.
For example, if we have a unit production A → B and a production rule B → CDE, we can replace A → B with A → CDE if CDE does not contain any non-terminal symbols.
The code begins by iterating through each variable A in the grammar. 
For each variable A, it then iterates through each production rule B → C for that variable. If B is a non-terminal and C is a terminal, the code replaces B → C with all productions of C. 
This process continues recursively until there are no more unit productions.
The code then returns the modified productions. </p>

```` python
    def removeUnitProductions(self):
        # For every variable A in the grammar
        for left, right in self.P.items():
            # For every production rule B -> C for A
            for e in right:
                # If B is a non-terminal and C is a terminal
                if len(e) == 1 and e in self.Vn:
                    # Replace B -> C with B -> productions of C
                    self.P[left].remove(e)
                    self.P[left].extend(self.P[e])
            new_P = self.P[left]
            for prod in new_P:
                if len(prod) == 1 and prod in self.Vn:
                    # Recursively apply the unit productions
                    self.removeUnitProductions()
        # Return the modified productions
        return self.P
````

* removeInaccessible()
<p align="justify">&ensp;&ensp;&ensp; This class implements a function called removeInaccessible that removes non-accessible symbols from the grammar. Here's how it works:
First, a set called accessible is created to store symbols that can be reached from the starting symbol. It is initialized as an empty set.
Then, for each production rule in the grammar, the function iterates over every symbol in the right-hand side of the rule and adds it to the accessible set.
Next, the function creates a list called removed to store all non-accessible symbols.
For each symbol in the grammar, if the symbol is not in the accessible set, it is added to the removed list.
Finally, the function removes each symbol in the removed list from the production rules and the set of non-terminal symbols Vn.
The end result is a modified version of the original grammar with all non-accessible symbols removed. The modified grammar is returned at the end of the function.</p>

``` python
    def removeInaccessible(self):
        # Create a set of symbols that can be reached from the starting symbol
        accessible = set()
        for left, right in self.P.items():
            for r in right:
                for w in r:
                    accessible.add(w)
        # Remove all non-accessible symbols from the grammar
        removed = []
        for left, right in self.P.items():
            if left not in accessible:
                removed.append(left)
        for r in removed:
            del self.P[r]
            self.Vn.remove(r)
        return self.P
```


* removeNonProductive()

<p align="justify">&ensp;&ensp;&ensp;This class implements the removal of non-productive variables from a given context-free grammar. 
The non-productive variables are those that do not derive any string of terminals in the grammar.
The algorithm starts by creating a set productive to hold the variables that derive a string of terminals.
Then, the algorithm loops through each production in the grammar, and if the production contains a terminal symbol, it adds the left side of the production to the productive set.
Next, the algorithm loops through each variable in the grammar and checks whether it is productive. If a variable is not productive, it removes it from the grammar. </p>

``` python
def removeNonProductive(self):
        productive = set()  # create a set to hold productive variables
        for left, right in self.P.items():  # loop through all productions
            for r in right:
                if r in self.Vt:  # if production contains a terminal symbol, skip it
                    productive.add(left)  # add left side of production to productive set
        for left, right in self.P.items():
            new_right = []
            for lt in left:
                if lt not in productive:  # if variable not in productive set, remove it
                    del self.P[lt]
                    del self.Vn[self.Vn.index(lt)]
                    return self.P
            for r in right:
                if len(r) > 1:  # if production contains more than one symbol
                    for w in r:
                        if w in self.Vn:
                            if w in new_right:  # avoid adding duplicates
                                break
                            elif w not in productive:  # if variable not productive, remove it
                                new_right.append(r.replace(w, ""))
                        elif w in self.Vt and w not in self.P[left]:  # if terminal symbol not in right side of production, add it
                            new_right.append(r.replace(r, w))
                        elif w in self.Vt and w in self.P[left]:  # if terminal symbol already in right side of production
                            if len(r) > 2:  # if production has more than 2 symbols, skip it
                                continue
                            new_right.append(r.replace(w, ""))  # remove terminal symbol
                        else:
                            continue
                else:
                    new_right.append(r)  # production contains only one symbol, add it to new_right
            self.P[left] = new_right  # update production
        return self.P
```

#### UnitTest Class

<p align="justify">&ensp;&ensp;&ensp; This is a unit testing class for the Grammar class. 
It defines several test methods that check different aspects of the Grammar class, 
such as conversion to a finite automaton, conversion to Chomsky normal form, 
removal of epsilon productions, and removal of inaccessible symbols. 
All test methods use a predefined context-free grammar as the input, and the expected output is also predefined.
The class uses the unittest module to perform the tests and check the results.
All tests have passed correctly. </p>

``` python
                         EXAMPLE 
    def test_to_chomsky_normal_form(self):
        self.assertEqual(self.grammar.toChomskyNormalForm(),
                         ({'S': ['b', 'a', 'A', 'ab', 'S'],
                           'B': ['a', 'bS'],
                           'C': ['abC']},
                          ['a', 'b'],
                          ['S', 'B', 'C']))
```

``` python
Ran 4 tests in 0.003s
```

## Results 

<p align="justify">&ensp;&ensp;&ensp;  The toChomskyNormalForm method of the Grammar class performs the conversion algorithm 
and returns the resulting Chomsky normal form productions, Vt, and Vn.
The algorithm consists of the following steps: </p>

* Remove epsilon productions
* Remove unit productions 
* Remove inaccessible symbols 
* Remove non-productive symbols 
<p align="justify">&ensp;&ensp;&ensp; The output of each step is printed to the console. The resulting Chomsky normal form is returned as a tuple containing the modified P, Vt, and Vn.
It is assumed that the input grammar is a context-free grammar, which can be represented using the defined parameters. 
The output of the algorithm is a context-free grammar in Chomsky normal form. </p>

##### Output

``` python
                      CFG TO CNF 
Var. 15 Grammar:  
Terminal: ['a', 'b']
Non-Terminal: ['S', 'A', 'B', 'C', 'D']
Productions: {'S': ['AC', 'bA', 'B', 'aA'], 'A': ['ABab', 'aS', 'epsilon'], 'B': ['a', 'bS'], 'C': ['abC'], 'D': ['AB']}
--------------------------
Step 1. Removing Epsilon: 
Vt:  ['a', 'b'] 
Vn:  ['S', 'A', 'B', 'C', 'D'] 
P:  {'S': ['C', 'b', 'B', 'a', 'C', 'b', 'aA'], 'A': ['ABab', 'aS'], 'B': ['a', 'bS'], 'C': ['abC'], 'D': ['B', 'AB']}
--------------------------
Step 2. Removing Unit Productions: 
Vt:  ['a', 'b'] 
Vn:  ['S', 'A', 'B', 'C', 'D'] 
P:  {'S': ['b', 'a', 'b', 'aA', 'abC', 'a', 'bS', 'abC'], 'A': ['ABab', 'aS'], 'B': ['a', 'bS'], 'C': ['abC'], 'D': ['AB', 'a', 'bS']}
--------------------------
Step 3. Removing Inaccessible: 
Vt:  ['a', 'b'] 
Vn:  ['S', 'A', 'B', 'C'] 
P:  {'S': ['b', 'a', 'b', 'aA', 'abC', 'a', 'bS', 'abC'], 'A': ['ABab', 'aS'], 'B': ['a', 'bS'], 'C': ['abC']}
--------------------------
Step 4. Removing Non-Productive: 
Vt:  ['a', 'b'] 
Vn:  ['S', 'B', 'C'] 
P:  {'S': ['b', 'a', 'ab', 'a', 'ab'], 'B': ['a', 'bS'], 'C': ['abC']}
--------------------------
Chomsky Normal Form:
Terminal: ['a', 'b']
Non-Terminal: ['S', 'B', 'C']
Productions: {'S': ['b', 'a', 'ab'], 'B': ['a', 'bS'], 'C': ['abC']}
```

**** 
## Conclusions: 

<p align="justify">&ensp;&ensp;&ensp;  In conclusion, the conversion of Context-Free Grammar (CFG) to Chomsky Normal Form (CNF) 
is an essential process in computational linguistics. By applying this conversion, we can simplify the grammar rules and make them more manageable for parsing algorithms.
In this laboratory work, we have successfully converted a given CFG into CNF by following a step-by-step procedure. 
We first eliminated epsilon productions and unit productions from the CFG. Finally, we converted the remaining productions into CNF.
In this laboratory work, I ensured the accuracy and correctness of my program by conducting a Unit Test.
Overall, this laboratory work helped us understand the importance of converting CFG into CNF and how to perform this conversion using a systematic approach.</p>

****

## References
1.https://www.tutorialspoint.com/automata_theory/chomsky_normal_form.htm
2.https://people.computing.clemson.edu/~goddard/texts/theoryOfComputation/9a.pdf
3.https://github.com/DrVasile/FLFA-Labs/blob/master/4_ChomskyNormalForm/task.md
